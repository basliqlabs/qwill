---
title: 'ارائه کاهش خطاهای نرم‌افزاری: راه‌کارهای عملی برای توسعه پایدار'
description: 'در دنیای توسعه نرم‌افزار، خطاها و باگ‌ها اجتناب‌ناپذیر هستند، اما با اتخاذ روش‌ها و ابزارهای مناسب می‌توان میزان و تأثیر آن‌ها را به حداقل رساند. در این مقاله جامع، به بررسی استراتژی‌های مختلف برای کاهش خطاهای نرم‌افزاری می‌پردازیم.'
publishDate: '2025-04-08'
updatedDate: '2025-09-06'
coverImage:
  src: '/images/cover-reduce-software-error-fa.webp'
  alt: ''
series: null
collections: ['presentation', 'software', 'test', 'lint']
authors: ['atareversei']
archived: false
draft: false
outdated: false
external: false
fire: false
ambientColor: null
---

> [!TIP] **توجه**
> این مقاله در اصل برای ارائه در **کلاس آزمون نرم‌افزار** در نیمسال دوم سال ۱۴۰۴ آماده شده بود،
> اما به دلیل کمبود وقت و فشردگی برنامه‌های درسی، فرصت ارائه پیدا نکرد.
> حال تصمیم گرفتم محتوای اون رو به صورت نوشته منتشر کنم تا برای دیگران هم مفید باشه.

## مقدمه: چرا باید حواسمون به خطاها باشه؟

نرم‌افزارها، ستون فقرات کسب‌وکارهای امروزی‌ان.
از خرید و فروش گرفته تا مدیریت تجهیزات و حتی ثبت فرم‌ها، همه‌چیز داره از طریق نرم‌افزار اتوماتیک انجام می‌شه.

حالا تصور کن فقط یه خطای کوچیک پیش بیاد:

- چندتا عملیات مهم متوقف می‌شن
- هر ثانیه که می‌گذره، ضرر مالی سنگین‌تر می‌شه
- آخرش هم اعتبار اون کسب‌وکار می‌ره زیر سوال

یعنی یه باگ کوچیک می‌تونه **تبدیل بشه به یه فاجعه بزرگ**.
از پاک شدن دیتای کاربرا بگیر تا هزینه‌های سرسام‌آور برای درست کردن مشکل.

برای همین، **جلوگیری از خطا** خیلی مهمه.
توی پروژه‌های کوچیک شاید بشه دستی همه‌چیز رو چک کرد،
ولی وقتی پروژه بزرگ شد، یا حتی حساس شد، این روش دیگه جواب نمی‌ده و باید **یه روند خودکار و سیستماتیک** داشته باشیم.

## چرا چک کردن دستی جواب نمی‌ده؟

خیلی ساده: چون آدمیزاد محدودیت داره!
سه تا عامل اصلی اینجا هست که باعث می‌شه نتونی همه‌چیز رو با چشم بررسی کنی:

### ۱. حجم پروژه

بیا از خودت بپرس، بزرگ‌ترین پروژه‌ای که تا حالا نوشتی چند خط بوده؟
ده خط؟ صد خط؟ هزار؟ ده هزار؟ یا حتی صد هزار خط؟

پروژه‌های سازمانی گاهی **به میلیون‌ها خط کد می‌رسن**.
حالا تصور کن با یه تغییر کوچیک تو یه ماژول، بخوای مطمئن بشی که هیچ جای دیگه خراب نشده.
عملاً غیرممکنه که این کار رو دستی انجام بدی.

### ۲. طول عمر پروژه

پروژه‌هایی هستن که چند هفته یا چند ماه روشون کار می‌کنی.
ولی بعضیا **سال‌ها یا حتی دهه‌ها** در حال توسعه هستن.

طبیعیه که:

- یه سری از قسمت‌های کد از یادت بره
- یا اون بخش رو کسی نوشته باشه که دیگه تو تیم نیست و هیچ‌کس نمی‌دونه دقیقاً چی تو ذهنش بوده

پس کد باید **خودش حرف بزنه**.
یعنی طوری نوشته بشه که حتی اگه ده سال بعد کسی اومد سراغش، بتونه بفهمه چی به چیه.

### ۳. تعداد آدمایی که روش کار می‌کنن

پروژه‌های کوچیک معمولاً یه نفر یا نهایت دو سه نفر دارن.
اما پروژه‌های بزرگ؟ گاهی **صدها یا حتی هزار نفر** در طول زمان روش کار می‌کنن.

هر چی آدم‌های بیشتری درگیر باشن:

- احتمال خراب‌کاری بیشتره
- اختلاف سلیقه‌ها بالا می‌ره
- و کنترل کیفیت هم سخت‌تر می‌شه

## انتخاب زبان: سیستم تایپ ناجی پروژه‌های بزرگ

زبان‌های برنامه‌نویسی دو دسته‌ان:

- **داینامیک (Dynamic Typing):**
  مثل پایتون یا جاوااسکریپت.
  هر متغیر می‌تونه در طول برنامه هر نوع داده‌ای رو بگیره. آزادی زیادی داری ولی مسئولیت هم با خودته.

- **استاتیک (Static Typing):**
  مثل جاوا، Go یا Rust.
  از همون اول باید مشخص کنی متغیر چه نوع داده‌ایه، و کامپایلر هم مواظبته که خراب‌کاری نکنی.

### مثال ساده

پایتون (داینامیک):

```python fileName="example.py"
name = "amirata"
name = 12
name = True
```

اما جاوا (استاتیک):

```java fileName="example.java"
public String name = "amirata";
name = 12;   // Can't assign an Integer to a String // [!code error]
name = true; // Can't assign a Boolean to a String // [!code error]
```

![پایتون و جاوا اگر انسان بودن😅](/images/java-vs-python.webp)

### چرا استاتیک برای پروژه‌های بزرگ بهتره؟

توی پروژه‌های بزرگ، داشتن یه سیستم تایپ قوی مثل اینه که یه **دفترچه راهنما داخل خود کد** داشته باشی.
کسی لازم نیست بره داکیومنت بخونه تا بفهمه یه متغیر چه داده‌ای رو نگه می‌داره،
چون **کد خودش حرف می‌زنه**.

> [!NOTE] تایپ داینامیک ≠ تایپ بی‌در و پیکر
> حتی توی زبان‌های داینامیک مثل پایتون یا جاوااسکریپت هم می‌شه **تایپ** اضافه کرد.
> مثل TypeScript برای جاوااسکریپت یا `mypy` برای پایتون.
> اینا کمک می‌کنن بخشی از مزایای تایپ استاتیک رو بدون عوض کردن زبان به دست بیاری.

یه مثال واقعی از تجربه کاری خودم:

```js fileName="popup.js"
function displayPopup(config) {
  if (config.name === 'warning') {
    config.display_duration = 12_000
  } else {
    // [!code word:display_duratoin:1]
    config.display_duratoin = false
  }
  // [!code word:data:1]
  config.data = undefined
}
```

این کد برای کامپوننت `Popup` نوشته شده بود که متعلق به ۱۲ سال پیشش بود و من قرار بود ری‌فکتورش کنم. چون کد با جاوااسکریپت (یه زبان داینامیک) نوشته شده بود، مشکلات زیر رو داشت:

1. یه تایپو ساده (`display_duratoin`) که راحت می‌تونه باگ بسازه و اینکه آیا من درستش کنم، مشکلی ایجاد می‌کنه؟
2. `display_duration` یه جا عدد داره، یه جا `false`! معلوم نیست دقیقاً چی باید باشه.
3. و مهم‌تر از همه: چرا `data` خالی می‌شه؟ هیچ‌کس نمی‌دونه! من اگه این فیلد رو کلاً در نظر نگیرم مشکلی به وجود میاد؟

واقعیتش اینه که جواب دادن به این سؤالات **سه ماه طول کشید**
و حتی آخرش هم مطمئن نشدیم تغییرات مطرح شده مشکل درست می‌کنه یا نه.

## لینتینگ (Linting)

لینتر مثل یه **دستیار وسواسی**ه که مدام حواست رو جمع می‌کنه و جلوی کلی دردسر رو می‌گیره. کارش اینه که کد رو خط به خط بررسی کنه و بهت بگه کجا ممکنه باگ داشته باشی، کجا از استانداردهای تیم تخطی کردی یا حتی کجا بی‌دلیل کد نوشتی.
مزیت اصلی لینتینگ اینه که قبل از این‌که کدت حتی اجرا بشه، کلی باگ بالقوه شناسایی و برطرف می‌شه. علاوه بر این، همه اعضای تیم مجبور می‌شن یه سبک یک‌دست برای کدنویسی داشته باشن، چیزی که باعث می‌شه بحث‌های بی‌پایان درباره «این کد تمیزه یا نه؟» به کمترین حد ممکن برسه.

چند تا از معروف‌ترین ابزارهای لینتینگ که ممکنه اسمشون به گوشت خورده باشه:

- **ESLint** برای جاوااسکریپت و TypeScript
- **Pylint** برای پایتون
- **Checkstyle** برای جاوا

> [!NOTE] ابزارهای یکپارچه در زبان‌های مدرن
> زبان‌هایی مثل **Go** و **Rust** از همون روز اول با فرمتر و لینتر خودشون عرضه شدن (`gofmt`، `cargo fmt`، `clippy`).
> یعنی نیازی به نصب ابزارهای جانبی نداری، و این باعث می‌شه همه با یک سبک واحد کد بزنن.

مثال ساده از ESLint:

```javascript fileName="example.js" copy
// Configuring ESLint
module.exports = {
  rules: {
    'no-console': 'warn', // warn the user if console is used
    'no-unused-vars': 'error' // error if a variable has been declared but hs not been used
  }
}

// ESLint in Action
let name = 'atareversei'
let studies = 'ce' // Error: no-unused-vars // [!code error]

console.log() // Warn: no-console // [!code warning]
```

> [!NOTE] Ruleهای بی‌شمار ESLint
> ESLint در مورد هر چیزی که فکرش رو بکنیم یا Rule داره یا با استفاده از پلاگین‌ها میشه بهش اضافه کرد.
> ولی لازم نیست همه Ruleها رو دستی تنظیم کنیم.
> شرکت‌های بزرگ مثل گوگل و فیسبوک کانفیگ‌های آماده دارن که می‌تونیم همون‌ها رو استفاده کنیم.

## فرمتینگ (Formatting)

فرمترها همون آدم‌های **اهل نظم و ترتیب** تیم هستن، با این تفاوت که اتوماتیک کار می‌کنن! وظیفه‌شون اینه که کد رو مرتب و زیبا نگه دارن. این یعنی فاصله‌گذاری‌ها درست باشه، تورفتگی‌ها دقیق رعایت بشن، خطوط طولانی به موقع شکسته بشن و حتی ترتیب ایمپورت‌ها مشخص باشه.
برخلاف لینتر، فرمتر هیچ تاثیری روی منطق برنامه نداره. فقط باعث می‌شه کد **تمیزتر، یک‌دست‌تر و راحت‌تر قابل خوندن** باشه؛ هم برای خودت، هم برای هم‌تیمی‌هات.

ابزارهای معروف فرمتینگ شامل این موارد هستن:

- **Prettier** برای جاوااسکریپت و CSS
- **Black** برای پایتون
- **gofmt** برای گولنگ

مثال:

```js fileName="prettier.config.js"
const prettierRc = {
  printWidth: 80,
  tabWidth: 2,
  semi: false,
  singleQuote: true
}

// Inconsistent formatting: double quotes, semicolons, and no indents
<!-- prettier-ignore --> // haha you didn't see this (👉ﾟヮﾟ)👉
if (name === "atareversei") {
name = "ata";
}

// After Prettier doing it's magic
if (name === 'ata') {
  name = 'ata'
}

```

> [!TIP] چرا فرمتر مهمه؟
> فرمترها جلوی دعواهای بی‌پایان درباره استایل کد رو می‌گیرن.
> وقتی Prettier یا Black می‌گه «اینجا باید دو فاصله باشه»، دیگه کسی بحث نمی‌کنه.
> قانون یکیه، همه هم مجبور به پیروی هستن.
>
> همچنین کد یکدست باعث خوانایی بیشتر پروژه می‌شه و کد هر چقدر خواناتر باشه، برنامه‌نویس هم باهاش راحت‌تر کار می‌کنه و کمتر دچار خطا می‌شه.

## کنترل ورژن با Git و GitHub

وقتی پروژه بزرگ می‌شه، داشتن **کنترل ورژن درست** حیاتی می‌شه.

### کد ریویو (Code Review)

قبل از این‌که یه تغییر به شاخه اصلی پروژه برسه، باید یه نفر دیگه اون رو بررسی کنه. این مرحله کمک می‌کنه باگ‌ها زودتر پیدا بشن، کیفیت کد بالاتر بره و اعضای تیم هم از همدیگه یاد بگیرن.
برای این‌که کد ریویو مؤثر باشه، بهتره بررسی‌ها خیلی بزرگ نباشن؛ مثلاً چیزی بین ۲۰۰ تا ۴۰۰ خط مناسبه. همچنین استفاده از template برای Pull Requestها کمک می‌کنه که همه‌چیز ساختارمند پیش بره. نکته آخر اینه که بازه زمانی بررسی نباید خیلی طولانی بشه؛ ایده‌آلش اینه که حداکثر ظرف ۲۴ ساعت انجام بشه.

![یک مثال از کد ریویو در گیت‌هاب؛ در این تصویر می‌توان کد قبلی و کد جدید و کامنت فرد ریویوکننده رو مشاهده کرد.](/images/github-code-review.webp)

> [!TIP] کد ریویو فقط برای باگ‌گیری نیست
> ۸۰٪ ارزش کد ریویو **انتقال دانش و تجربه** بین اعضای تیمه.
> خیلی وقت‌ها یه کد رو ریویو می‌کنی و یه چیزی یاد می‌گیری که هیچ داکیومنتی بهت نمی‌گفت.

### برنچ‌های محافظت‌شده (Protected Branches)

برای این‌که شاخه اصلی پروژه (مثل `main` یا `master`) هیچ وقت خراب نشه، باید مطمئن بشیم که هیچ‌کس نمی‌تونه **مستقیم روی اون push کنه**.
این کار معمولاً با گذاشتن چند قانون انجام می‌شه. مثلاً همه تغییرات باید حتماً از طریق Pull Request وارد بشن و قبل از merge شدن، حداقل دو نفر اون‌ها رو بررسی کرده باشن. علاوه بر این، همه تست‌ها باید پاس بشن، خطاهای لینتر بررسی بشن و در نهایت هرگونه push مستقیم به این شاخه ممنوع باشه. اینطوری احتمال خراب شدن شاخه اصلی به حداقل می‌رسه.

> [!NOTE] صاحب هر کد مشخصه!
> با فایل `CODEOWNERS`، وقتی یه فایل تغییر می‌کنه، گیت‌هاب به طور خودکار می‌دونه چه کسی باید اون رو ریویو کنه.
> این باعث می‌شه هیچ بخشی از پروژه **بی‌مسئول و بی‌صاحب** نمونه.

### CI/CD

وقتی هر تغییری به ریپازیتوری push می‌شه، می‌تونیم با استفاده از یک سیستم **یکپارچه‌سازی و تحویل مستمر** (CI/CD) همه‌چیز رو اتوماتیک کنیم.
به محض این‌که کد جدید بیاد، تست‌ها به صورت خودکار اجرا می‌شن و اگه مشکلی وجود داشته باشه، سریع بهت گزارش داده می‌شه. اگه همه‌چیز اوکی باشه، دیپلوی کردن نسخه جدید هم بدون دردسر انجام می‌شه. این روند باعث می‌شه خطاها زودتر شناسایی بشن و انتشار نسخه‌های جدید سریع‌تر و مطمئن‌تر باشه.

> [!NOTE] همه چیز اتوماتیک
> با CI/CD می‌شه مطمئن شد **قبل از merge** شدن یه تغییر، همه تست‌ها پاس می‌شن.
> یعنی هیچکس حتی نمی‌تونه ناخواسته کدی رو وارد شاخه اصلی کنه که باعث خرابی پروژه بشه.

نمونه ساده از GitHub Actions:

```yaml fileName="deploy.yaml"
name: CI Pipeline

# Run this action on push and pull request events
on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci # Install the dependencies
      - name: Run lint
        run: npm run lint # Lint the project
      - name: Run tests
        run: npm test # Run the tests
```

## تست نرم‌افزار: انواع و استراتژی‌ها

تست نرم‌افزار فرآیندی **سیستماتیک و معمولاً خودکار** برای اطمینان از اینه که برنامه دقیقاً همون‌طور که انتظار داریم عمل می‌کنه.
تست به ما کمک می‌کنه که خطاها رو زودتر پیدا کنیم، قبل از این که به دست کاربر برسن یا در محیط پروداکشن فاجعه درست کنن.

برای پوشش کامل سیستم، تست‌ها معمولاً در چند سطح مختلف انجام می‌شن:

- **تست‌های فرانت‌اند**: بررسی رفتار UI و تعاملات کاربر.
- **تست‌های بک‌اند**: بررسی منطق سیستم، APIها و پایگاه داده.
- **تست‌های end-to-end**: شبیه‌سازی تجربه‌ی واقعی کاربر از ابتدا تا انتها.

### تست‌های فرانت‌اند

تست فرانت‌اند متمرکز روی اینه که رابط کاربری هم درست کار کنه، هم درست به بک‌اند متصل بشه.
به‌طور کلی سه دسته اصلی داریم:

#### تست واحد یا Unit Test

یونیت تست کوچک‌ترین بخش‌های نرم‌افزار رو به صورت **ایزوله (isolated)** بررسی می‌کنه.
تو دنیای فرانت‌اند، معمولاً توابع ساده یا کامپوننت‌های کوچک رو بدون هیچ وابستگی خارجی تست می‌کنیم.

مثلاً تابعی که query string می‌سازه:

```ts fileName="generateQueryParams.ts"
export function generateQueryParams(params: Record<string, string>): string {
  const keys = Object.keys(params)
  if (keys.length === 0) return ''
  return '?' + keys.map((k) => `${k}=${encodeURIComponent(params[k])}`).join('&')
}

generateQueryParams({ id: 1, name: 'ata' }) // "?id=1&name=ata"
```

و تست این تابع:

```ts fileName="generateQueryParams.test.ts"
describe('generateQueryParams', () => {
  const testCases = [
    {
      data: { queryParams: { name: 'ata' } },
      expected: '?name=ata',
      goal: 'handles basic usage'
    },
    {
      data: { queryParams: {} },
      expected: '',
      goal: 'handles empty objects'
    }
  ]

  testCases.forEach((tc) => {
    it(tc.goal, () => {
      expect(generateQueryParams(tc.data.queryParams)).toBe(tc.expected)
    })
  })
})
```

این تست داره از **تکنیک Table-Driven** استفاده می‌کنه.

ایده‌ش خیلی ساده‌ست: به جای اینکه برای هر حالت یه تست جدا بنویسی، **یه جدول از ورودی‌ها و خروجی‌های مورد انتظار** درست می‌کنی و بعد با یه حلقه از روی این جدول رد می‌شی و هر مورد رو تست می‌کنی. این کار باعث می‌شه کدت تمیزتر و کوتاه‌تر بشه و اگه خواستی تست جدید برای این تابع اضافه کنی دردسرش کم‌تر بشه.

اینجا یه آرایه به اسم `testCases` داریم که در واقع همون **جدول ورودی/خروجی** ماست. هر آبجکت توی این جدول سه تا آیتم داره:

- `data`: ورودی‌ای که می‌خوایم به تابع بدیم.
- `expected`: خروجی‌ای که انتظار داریم برگرده.
- `goal`: توضیح کوتاه برای این‌که بفهمیم این تست داره چی رو بررسی می‌کنه.

> [!TIP] مزیت یونیت تست
> مزیت یونیت تست به اجرای خیلی سریعشه. به طوری که کل تست‌های یه پروژه رو شاید بشه در یک دقیقه اجرا کرد و نتیجه رو دید.
> یونیت تست باید یک واحد کوچیک از کد مثل یک تابع یا کلاس و متدهاش رو هدف قرار بده.
> تست‌های واحد باید سریع باشن و وابسته به دیتابیس یا API نباشن. هر چیزی که خارج از واحد کده باید ماک بشه.

#### تست یکپارچگی (Integration Test)

این تست بررسی می‌کنه که **چند بخش از سیستم در کنار هم درست کار می‌کنن**.
برای مثال، فرض کن توی یه فرم کاربر اضافه می‌کنیم. این تست چک می‌کنه که:

- فرم اطلاعات رو درست بگیره
- درخواست درست به بک‌اند ارسال بشه
- و نتیجه به درستی توی UI نمایش داده بشه

برای نمونه، در قطعه کدهای زیر سعی داریم کامپوننت لیست و ایجاد کاربر رو تست کنیم. برای همین توی منطق تست یه کاربر جدید ایجاد می‌کنیم و چک می‌کنیم ببینیم کاربر جدید توی لیست اضافه شد یا نه:

```tsx fileName="UserList.test.tsx"
it('should handle adding a new user', async () => {
  // Let's first render the component we want to test
  render(<UserList />)

  // There must exist a text with value of "Dashboard", If not found then this
  // test won't pass.
  await screen.findByText('Dashboard')

  // Let's fill the form and create a new user.
  userEvent.type(screen.getByLabelText(/name/i), 'Javad Vaseghi')
  userEvent.type(screen.getByLabelText(/email/i), 'j.vas@t.com')
  userEvent.click(screen.getByRole('button', { name: /add user/i }))

  // New user should have been added by now.
  await waitFor(() => {
    expect(screen.getByText('Javad Vaseghi')).toBeInTheDocument()
  })
})
```

و حالا کامپوننتی که تستش کردیم:

```tsx fileName="UserList.tsx"
const UserList = () => {
  const [newUser, setNewUser] = useState({ name: '', email: '' })
  const [users, setUsers] = useState([])

  const handleAddUser = async (e) => {
    e.preventDefault()
    const response = await fetch(`${API_BASE_URL}/users`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newUser)
    })
    const createdUser = await response.json()
    setUsers((prev) => [...prev, createdUser])
  }

  return (
    <div>
      <form onSubmit={handleAddUser}>
        <label htmlFor="name">Name</label>
        <input name="name" onChange={(e) => setNewUser({ ...newUser, name: e.target.value })} />

        <label htmlFor="email">Email</label>
        <input name="email" onChange={(e) => setNewUser({ ...newUser, email: e.target.value })} />

        <button type="submit">Add User</button>
      </form>

      {users.map((user) => (
        <p key={user.id}>{user.name}</p>
      ))}
    </div>
  )
}
```

برای ماک کردن API، از [MSW](https://mswjs.io/) استفاده می‌کنیم:

```js fileName="mocks.js"
import { rest } from 'msw'

export const handlers = [
  rest.post(`${API_BASE_URL}/users`, (req, res, ctx) => {
    return res(ctx.json({ id: 1, ...req.body }))
  })
]
```

و در تست‌ها سرور ماک رو راه‌اندازی می‌کنیم:

```js fileName="jest.setup.js"
import { server } from './mocks/server'

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

> [!TIP] دلیل استفاده از تست یکپارچگی
> تست یکپارچگی برای زمانی که می‌خوایم منطق چند بخش با هم رو تست کنیم عالیه، بدون این که به یک سرویس واقعی نیاز داشته باشیم.

#### تست End-to-End (E2E)

این تست‌ها شبیه‌سازی کامل **تجربه کاربر واقعی** هستن.
مثلاً مرورگر باز می‌شه، فرم پر می‌شه و نتیجه دقیقاً مثل یک کاربر واقعی بررسی می‌شه. ابزارهای محبوب مثل **Cypress** و **Playwright** برای این کار استفاده می‌شن.

![محیط گرافیکی Playwright](/images/e2e-playwright.webp)

> [!TIP] پس بهتر نیست تمام تست‌ها رو از نوع E2E بنویسیم؟
> این تست‌ها کندترن، پس فقط سناریوهای حیاتی مثل ثبت‌نام یا خرید آنلاین باید اینجا پوشش داده بشن.
> البته تیم‌های مختلف استراتژی‌های مختلفی دارن. بعضی تیم‌های خیلی حرفه‌ای ممکنه شصت درصد تایمشون رو اختصاص بدن به تست‌های یونیت، سی درصد اختصاص بدن به یکپارچه‌سازی و بقیه ده درصد رو E2E انجام بدن و همچنین تیم‌هایی صاحب‌نظر هم هستند که اکثر تایمشون رو برای E2E صرف می‌کنن. اینکه در نهایت چه روشی برای شما موثرتره بستگی به پروژه و بودجه زمانی شما داره.

#### استوری‌بوک و کروماتیک

[Storybook](https://storybook.js.org/) ابزاریه برای ساخت و تست بصری کامپوننت‌ها به صورت isolated.
این کار باعث می‌شه بدون نیاز به کل برنامه، حالت‌های مختلف یک کامپوننت رو ببینیم و تست کنیم.

```tsx fileName="AsyncButton.story.tsx"
import { Meta, StoryObj } from '@storybook/react'
import { fn } from '@storybook/test'
import { AsyncButton } from './AsyncButton'

const meta: Meta<typeof AsyncButton> = {
  title: 'Async Button',
  component: AsyncButton,
  args: {
    clickHandler: fn()
  }
}

export default meta

type Story = StoryObj<typeof AsyncButton>

export const Default: Story = {
  args: {
    children: 'Submit'
  }
}
```

قطعه کد بالا باعث میشه کامپوننت `AsyncBtton` رو بتونیم به شکل ایزوله توی استوری‌بوک داشته باشیم. استوری‌بوک بیش‌تر برای داشتن آمار کامپوننت‌ها، و تعامل راحت‌تر تیم‌های دیزاین و توسعه به درد می‌خوره.

![کامپوننت AsyncButton با Propهای قابل تغییرش رو می‌تونیم اینجا مشاهده کنیم](/images/storybook-simple.webp)

به‌همراه Storybook می‌شه از **Chromatic** استفاده کرد تا به صورت خودکار اسکرین‌شات بگیره و هر تغییری در ظاهر UI رو شناسایی کنه.
این موضوع به خصوص برای تیم‌های بزرگ عالیه، چون دیگه نیاز نیست دستی همه تغییرات رو چک کنیم. این ابزار برای تیم‌هایی که کامپوننت لایبرری خودشون رو می‌نویسن خیلی کاربردیه، چون کوچکترین تغییری در لایه‌های زیرساختی CSS می‌تونه تاثیرات ناخواسته‌ای روی کامپوننت‌های متفاوت داشته باشه و بهتره بررسی این تغییرات به شکل سیستماتیک انجام بشه.

### تست‌های بک‌اند

تست‌های بک‌اند متمرکز بر بررسی **منطق سیستم، APIها و تعامل با دیتابیس** هستن.
سه سطح مهم داریم:

#### یونیت تست (Unit Test)

در بک‌اند، یونیت تست برای بررسی **توابع یا ماژول‌های کوچک بدون وابستگی به منابع خارجی** استفاده می‌شه.
مثلاً یک تابع که خطاها رو ساختارمند می‌کنه:

```go fileName="richerror.go"
func buildRichError(msg string, kind string) RichError {
  return RichError{Message: msg, Kind: kind}
}
```

تست این تابع:

```go fileName="richerror_test.go"
func TestBuildRichError(t *testing.T) {
  testCases := []struct {
    description string
    msg         string
    kind        string
    expected    string
  }{
    {"basic error", "failed to connect", "NETWORK", "NETWORK"},
    {"validation error", "invalid input", "VALIDATION", "VALIDATION"},
  }

  for _, tc := range testCases {
    t.Run(tc.description, func(t *testing.T) {
      err := buildRichError(tc.msg, tc.kind)
      if err.Kind != tc.expected {
        t.Errorf("Expected %v, got %v", tc.expected, err.Kind)
      }
    })
  }
}
```

#### تست API

این تست‌ها بررسی می‌کنن که endpointهای REST یا GraphQL دقیقاً طبق انتظار کار کنن.
در Go معمولاً از ابزارهایی مثل `httptest` یا کتابخونه‌هایی مثل **Supertest** (برای Node.js) استفاده می‌شه. البته میشه از ابزارهایی مثل Postman یا Bruno هم استفاده کرد.

```go fileName="user_api_test.go"
func TestGetUser(t *testing.T) {
  req := httptest.NewRequest(http.MethodGet, "/users/1", nil)
  w := httptest.NewRecorder()

  router := setupRouter()
  router.ServeHTTP(w, req)

  if w.Code != http.StatusOK {
    t.Errorf("Expected status 200, got %d", w.Code)
  }
}
```

#### تست پایگاه داده (Database Tests)

این تست‌ها برای **اطمینان از صحت کوئری‌ها و مهاجرت‌ها (migrations)** هستن.
اینجا دو استراتژی رایج وجود داره:

1. **ماک کردن پایگاه‌داده**: سریع‌تره و برای تست یونیت عالیه.
2. **پایگاه‌داده واقعی تستی** (مثلاً PostgreSQL با Docker): کندتره ولی رفتار واقعی رو شبیه‌سازی می‌کنه.

```go fileName="user_repository_test.go"
func TestCreateUser(t *testing.T) {
  db := setupTestDB() // Either a simple in-memory or a fully fledged database
  repo := NewUserRepository(db)

  user := User{Name: "Ata", Email: "ata@example.com"}
  err := repo.Create(user)

  if err != nil {
    t.Fatalf("failed to create user: %v", err)
  }
}
```

## تست‌های اضافی برای کیفیت بهتر

توی مراحل قبلی، در مورد تست‌های اصلی مثل یونیت تست، یکپارچگی و E2E صحبت کردیم، اما اینا تمام ماجرا نیستن. برای اینکه کیفیت نرم‌افزار رو به سطح بالاتری ببریم، یک سری تست‌های تخصصی‌تر هم وجود داره که هر کدوم هدف خاصی رو دنبال می‌کنن.

### تست دسترسی‌پذیری (Accessibility Testing)

تصور کنید یک کاربر نابینا یا فردی که محدودیت حرکتی داره یا اصلا کاربری که فقط از کیبورد استفاده میکنه (خودم😅)، می‌خواد با نرم‌افزار شما کار کنه. آیا رابط کاربری شما طوری طراحی شده که این فرد هم بتونه بدون مشکل ازش استفاده کنه؟
اینجاست که تست دسترسی‌پذیری وارد می‌شه. این تست بررسی می‌کنه که اپلیکیشن شما برای همه‌ی کاربران، فارغ از شرایط جسمی یا محدودیت‌های خاص، قابل استفاده هست یا نه. برای انجام این تست، ابزارهایی مثل **Axe** یا **Lighthouse** وجود دارن که می‌تونن به صورت خودکار مشکلات احتمالی رو شناسایی کنن.

![ابزار Lighthouse که داخل گوگل کروم تعبیه شده، می‌تونه وبسایت‌ها رو از نظر دسترسی‌پذیری، بهینگی و موارد دیگه بررسی کنه.](/images/lighthouse-report.webp)

### تست عملکرد (Performance Testing)

حتی اگه اپلیکیشن شما بدون باگ و با رابط کاربری عالی کار کنه، اگه در لحظه‌ی نیاز نتونه به درخواست‌های کاربر به سرعت پاسخ بده، کل تجربه خراب می‌شه.
تست عملکرد دقیقا برای این طراحی شده که بفهمیم سیستم تحت فشار چه رفتاری نشون می‌ده. این تست‌ها معمولا به دو دسته‌ی اصلی تقسیم می‌شن:

- **Load Testing**: شبیه‌سازی تعداد زیادی کاربر که به صورت هم‌زمان با سیستم تعامل دارن، تا ببینیم آیا سرویس هنوز پایدار عمل می‌کنه یا نه.
- **Stress Testing**: رفتن فراتر از ظرفیت عادی سیستم برای پیدا کردن نقطه‌ای که در اون سیستم از کار می‌افته یا به اصطلاح _crash_ می‌کنه.

ابزارهای معروف برای این نوع تست شامل **k6** و **JMeter** هستن که می‌شه باهاشون سناریوهای مختلف رو طراحی کرد و به صورت اتوماتیک اجرا گرفت.

### تست امنیت (Security Testing)

اهمیت امنیت در پروژه‌های نرم‌افزاری رو نمی‌شه دست کم گرفت. حتی یک آسیب‌پذیری کوچک می‌تونه کل سیستم رو به خطر بندازه. تست امنیت مجموعه‌ای از تکنیک‌هاست برای شناسایی این آسیب‌پذیری‌ها قبل از اینکه مهاجمان بتونن ازشون سوءاستفاده کنن.
این تست‌ها معمولا شامل چند مرحله می‌شن:

- **اسکن وابستگی‌ها**: بررسی کتابخانه‌ها و پکیج‌های خارجی که پروژه بهشون وابسته است. ابزارهایی مثل **Dependabot** به طور خودکار هشدار می‌دن اگر نسخه‌ای از یک پکیج دارای مشکل امنیتی باشه.
- **اسکن کد**: تحلیل استاتیک سورس‌کد برای پیدا کردن الگوهای ناامن یا اشتباهات رایج. ابزارهای معروف در این زمینه شامل **SonarQube** و **Snyk** هستن.
- **تست نفوذ (Penetration Testing)**: شبیه‌سازی حملات واقعی برای بررسی مقاومت سیستم. این تست معمولا توسط تیم‌های تخصصی امنیتی انجام می‌شه.

## مانیتورینگ در محیط عملیاتی

حتی با انجام همه‌ی این تست‌ها، باز هم هیچ سیستمی بی‌نقص نیست. بعضی خطاها فقط وقتی خودشون رو نشون می‌دن که سیستم در محیط واقعی و با ترافیک واقعی کار کنه. به همین دلیل، **مانیتورینگ** یا نظارت لحظه‌ای روی نرم‌افزار اهمیت زیادی پیدا می‌کنه.

مانیتورینگ به تیم توسعه کمک می‌کنه تا مشکلات رو قبل از کاربران شناسایی و برطرف کنن. برای این کار ابزارهای مختلفی وجود داره که هر کدوم روی بخش خاصی تمرکز می‌کنن:

- **Logging**: ثبت لاگ‌های دقیق از رویدادهای سیستم برای بررسی رفتار برنامه در شرایط مختلف. ابزارهایی مثل **ELK Stack** (Elasticsearch, Logstash, Kibana) برای این کار پرکاربرد هستن.
- **Metrics**: جمع‌آوری داده‌های آماری مثل تعداد درخواست‌ها در ثانیه، مدت زمان پاسخ‌دهی، یا مصرف منابع. **Prometheus** یکی از ابزارهای معروف در این زمینه است.
- **Alerting**: تعریف هشدارها برای زمانی که مقادیر مشخصی از حد نرمال خارج بشن. مثلا اگر CPU برای ۵ دقیقه بالای ۹۰٪ بمونه، یک هشدار به تیم پشتیبانی ارسال بشه.

به کمک این ابزارها می‌شه نه‌تنها خطاها رو سریع پیدا کرد، بلکه با تحلیل داده‌ها در طول زمان، پیش‌بینی کرد چه جاهایی ممکنه در آینده دچار مشکل بشن.

## جمع‌بندی

کاهش خطاهای نرم‌افزاری یک فرآیند یک‌باره نیست، بلکه یک سفر دائمیه. از انتخاب درست زبان برنامه‌نویسی و استفاده از سیستم تایپ قوی، تا لینتینگ و فرمتینگ برای داشتن کدی تمیز و یک‌دست، از کدریویو و برنچ‌های محافظت‌شده گرفته تا تست‌های مختلف، همه و همه مثل قطعات یک پازل کنار هم قرار می‌گیرن تا نرم‌افزار شما پایدارتر و قابل اعتمادتر بشه.

در نهایت، مانیتورینگ و جمع‌آوری بازخورد از محیط عملیاتی کمک می‌کنه که نه‌تنها خطاها رو سریع شناسایی کنید، بلکه به مرور زمان، روند توسعه رو به سمت بهبود مداوم هدایت کنید. این چرخه‌ی پیوسته باعث می‌شه که با هر نسخه‌ی جدید، محصولی با کیفیت‌تر و پایدارتر در اختیار کاربران قرار بگیره.
